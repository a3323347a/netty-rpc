## netty-rpc
使用netty自定义rpc框架

### 一、RPC实现步骤

RPC框架版本一

主要实现目标：模仿Dubbo，约定好服务端和客户端接口和协议，消费者远程调用服务端，服务端返回一个字符串，底层使用netty来完成，序列化采用JSON，具体步骤：

- 创建一个公共的接口项目，并定义好可供远程调用的方法和接口；
- 创建一个服务提供者项目，该项目启动后会一直监听某个端口，并处理客户端发送的请求，按照约定格式返回数据；
- 创建一个服务消费者项目，该类需要透明地调用不存在本项目中的方法，内部使用Netty请求提供者并返回数据，其实调用的原理是，当调用接口的方法时，使用动态代理，然后将调用**哪个接口**的**哪个方法**，作为请求参数，传递给Netty的服务端，这样来通信的。

服务端接收请求，从参数中解析出接口和方法，然后调用具体的实现类，将结果返回给客户端

### 二、RPC框架升级版本（二）

在版本一中，已经实现了RPC的基础部分，即消费者可以通过接口代理方式来调用远程方法，但是该方式仍然有弊端：服务的IP、端口仍然是硬编码方式，一旦服务提供方更改了地址，我们仍需修改代码来完成调用，这显然不符合好代码的设计，因此本章我们就来解决这个问题。我们借助Zookeeper来实现注册中心功能。

大概的步骤如下：

- 服务端启动后将自己的地址注册到ZK服务器上；
- 客户端运行一个后台脚本去调用各个服务器，并记录每个服务器的响应时间，作为消费者调用时的负载均衡策略；
- 客户端调用前从Zookeeper上获取服务器列表，并选择响应时间最短（性能最好）的一台服务器进行调用。
